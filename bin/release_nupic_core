#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (NuPIC)
# Copyright (C) 2015, Numenta, Inc.  Unless you have an agreement
# with Numenta, Inc., for a separate license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# ----------------------------------------------------------------------

import sys
import os
import subprocess
from optparse import OptionParser

from libsaas.services import github
from libsaas.http import HTTPError

# Files that will be modified.
VERSION_FILE = "VERSION"
CHANGELOG_FILE = "CHANGELOG.md"
DOXYFILE = "Doxyfile"

# Used for creating the next version after the release. After 1.2.3 comes
# 1.2.3.dev0. Named this way because distutils complains if you use "-dev".
# You know you hate it when distutils complains.
DEV_SUFFIX = ".dev0"

NUPIC_CORE = None
GH_TOKEN = None

SLUG = "numenta/nupic.core"

CWD = os.getcwd()

BUGFIX_RELEASE = "bugfix"
MINOR_RELEASE = "minor"
MAJOR_RELEASE = "major"

DEFAULT_RELEASE_TYPE = BUGFIX_RELEASE
DEFAULT_REMOTE = "upstream"

verbose = False
gh = None


# Options parsing.
parser = OptionParser(
  usage="%prog [options]\n\n"
        """
Pushes a new NuPIC Core release using git tags and the GitHub API. Users must have push access and a GitHub access token.

## Requirements:
- git
- [GitHub access token](https://github.com/blog/1509-personal-api-tokens)
  - `export GH_ACCESS_TOKEN=<token>`
- `export NUPIC_CORE=<path-to-nupic.core-checkout>`
- Push access to target git repository
- `pip install libsaas`

## Usage

> ./release_nupic_core [options]

It's assumed you're releasing NuPIC Core, so the value of the `NUPIC_CORE` environment variable will be used for the repository location.
        """
)
parser.add_option(
  "-v",
  "--verbose",
  action="store_true",
  default=False,
  dest="verbose",
  help="Print debugging statements.")
parser.add_option(
  "-d",
  "--dry-run",
  action="store_true",
  default=False,
  dest="dry_run",
  help="Prevents pushing to remote branch.")
parser.add_option(
  "-y",
  "--yes",
  action="store_true",
  default=False,
  dest="auto_confirm",
  help="Prevents command line confirmation for the release. "
       "Hopefully you know what you're doing.")
parser.add_option(
  "-r",
  "--remote",
  default=DEFAULT_REMOTE,
  dest="remote",
  help="Which remote location to push to (default 'upstream').")
parser.add_option(
  "-n",
  "--next-release",
  default=None,
  dest="next_release",
  help="After this release has completed, what will the next release version"
       "be (if not supplied, it will rollover to bugfix release. You won't"
       "need to use this option unless you need to the next release to break"
       "semantic versioning.")
parser.add_option(
  "-s",
  "--semantic-release-type",
  default=DEFAULT_RELEASE_TYPE,
  dest="release_type",
  help="Type of semantic release to execute. Must be either \"%s\", "
       "\"%s\", or \"%s\" (default \"%s\")."
       % (BUGFIX_RELEASE, MINOR_RELEASE, MAJOR_RELEASE, BUGFIX_RELEASE))



def replaceInFile(from_value, to_value, file_path):
  with open(file_path, "r") as f:
    contents = f.read()
  with open(file_path, "wb") as f:
    f.write(contents.replace(from_value, to_value))



def debug(msg):
  if verbose:
    print msg



def die(msg):
  print msg
  exit(-1)



def queryYesNo(question, default="no"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")



def pause(message):
  sys.stdout.write(message + " To resume this script, press enter.")
  raw_input()



def tagExists(tag):
  git_command = "git tag"
  debug(git_command)
  existing_tags = subprocess.check_output(git_command, shell=True).strip().split("\n")
  return tag in existing_tags



def bailOut(msg):
  debug("Checking out changed files before bailing out...")

  git_command = "git checkout %s %s %s" \
                % (CHANGELOG_FILE, VERSION_FILE, DOXYFILE)
  debug(git_command)
  subprocess.call(git_command, shell=True)
  die(msg)



def repoNeedsUpdate(remote):
  debug("Checking if local repo needs to be synced with %s..." % remote)

  git_command = "git fetch %s" % remote
  debug(git_command)
  subprocess.call(git_command, shell=True)

  # This gives us a log of all the commits on <remote>/master that aren't on
  # the local checkout's HEAD.
  git_command = "git log HEAD..%s/master --oneline" % remote
  debug(git_command)
  gitlog = subprocess.check_output(git_command, shell=True).strip()

  # If the output is not empty, then the repo needs updating.
  return len(gitlog) > 0



def userHasPushAccess(remote):
  debug("Checking if user has push access to %s..." % remote)

  git_command = "git push --dry-run %s master" % remote
  debug(git_command)
  status = subprocess.call(git_command, shell=True)
  # User only has push access if exit status of the push call was 0.
  return status == 0



def findVersions(dev_version, release_type):
  # Turns "X.Y.Z.dev0 into "X.Y.Z".
  expected_next_version = ".".join(dev_version.split(".")[:-1])
  release_split = [int(i) for i in expected_next_version.split('.')]

  release_split[-1] -= 1
  previous_version = ".".join([str(i) for i in release_split])

  if release_type == BUGFIX_RELEASE:
    release_version = expected_next_version
  elif release_type == MINOR_RELEASE:
    # Bump minor number.
    release_split[-2] += 1
    # Rollover bugfix number.
    release_split[-1] = 0
    release_version = ".".join([str(i) for i in release_split])
  else:
    # Bump major number.
    release_split[0] += 1
    # Rollover minor and bugfix numbers.
    release_split[1] = 0
    release_split[2] = 0
    release_version = ".".join([str(i) for i in release_split])

  return previous_version, release_version



def getReleaseNotes(release_number):
  release_notes = []
  in_release = False
  with open(CHANGELOG_FILE, "r") as f:
    for line in f.readlines():
      if in_release:
        if line.startswith("##"):
          break
        release_notes.append(line)
      if line == "## %s\n" % release_number:
        in_release = True
  return "".join(release_notes)



def updateChangelog(gitlog, release_version):
  # Changelog needs a little more care.
  debug("\tUpdating CHANGELOG.md...")
  # This is a bit more complex than a substitution.
  with open(CHANGELOG_FILE, "r") as f:
    changelog_contents = f.readlines()
  new_changelog_contents = []
  for line in changelog_contents:
    # At the top of the changelog, add a line for this release version.
    if line == "# Changelog\n":
      new_changelog_contents.append(line)
      new_changelog_contents.append("\n## %s\n\n" % release_version)
      changelog_count = 0
      # Loop through all the git log messages since the last version.
      for log_line in gitlog:
        # There are some commit messages we can always ignore.
        if not log_line.startswith("Merge pull request") \
                and not log_line.startswith("Merge branch") \
                and not log_line.startswith("Updates nupic.core to"):
          # Ask the user doing the release if they want each commit message in the
          # changelog.
          include = "Include this change in the CHANGELOG?\n\t\"%s\"" % log_line
          if queryYesNo(include):
            changelog_count += 1
            new_changelog_contents.append("* %s\n" % log_line)
    else:
      new_changelog_contents.append(line)
  with open(CHANGELOG_FILE, "wb") as f:
    f.writelines(new_changelog_contents)
  manual_changelog_change = queryYesNo(
    "\nDo you want to make any manual changes to the CHANGELOG file before "
    "continuing?"
  )
  if manual_changelog_change:
    pause("Edit the CHANGELOG.md file now and save without committing.")



# def updateNupicBindingsVersion():
#   print "\nUpdating nupic.bindings version number in README.md..."
#   required_bindings_version = None
#   current_bindings_version = None
#   with open(REQUIREMENTS_FILE, "r") as f:
#     for line in f.readlines():
#       if line.startswith("nupic.bindings"):
#         required_bindings_version = line.split("==")[-1].strip()
#   if required_bindings_version is None:
#     raise Exception("Could not identify nupic.bindings version from %s."
#                     % REQUIREMENTS_FILE)
#   with open(README_FILE, "r") as f:
#     for line in f.readlines():
#       if "nupic.bindings/nupic.bindings-" in line:
#         # Find the nupic.bindings version number to replace
#         current_bindings_version = line.split("/")[-1].split("-")[1].strip()
#   if required_bindings_version != current_bindings_version:
#     print "Updating nupic.bindings version from %s to %s" \
#           % (current_bindings_version, required_bindings_version)
#     replaceInFile(
#       current_bindings_version, required_bindings_version, README_FILE
#     )



def updateNupicCoreFiles(dev_version, gitlog, previous_version, release_version):
  print "\nUpdating files..."
  # These files can be updated with a simple find/replace:
  for target_file in [VERSION_FILE, DOXYFILE]:
    debug("\tUpdating %s..." % target_file)
    replaceInFile(dev_version, release_version, target_file)
  updateChangelog(gitlog, release_version)



def commitRelease(release_version):
  print "\nCommitting release..."
  git_command = "git commit -am \"Release %s.\" --no-verify" % release_version
  debug(git_command)
  subprocess.call(git_command, shell=True)



def tagRelease(release_version):
  print "\nTagging release..."
  if tagExists(release_version):
    delete_tag = queryYesNo(
      "Tag %s already exists! Delete it?" % release_version
    )
    if delete_tag:
      git_command = "git tag -d %s" % release_version
      debug(git_command)
      subprocess.call(git_command, shell=True)
    else:
      die("A tag for release %s already exists." % release_version)
  git_command = "git tag -a %s -m \"Release %s\"" \
                % (release_version, release_version)
  debug(git_command)
  subprocess.call(git_command, shell=True)


def pushRelease(release_version, remote):
  print "\nPushing to %s..." % remote
  git_command = "git push %s master" % remote
  debug(git_command)
  subprocess.call(git_command, shell=True)
  git_command = "git push %s %s" % (remote, release_version)
  debug(git_command)
  subprocess.call(git_command, shell=True)



def getGitLog(previous_version):
  git_command = "git log %s..HEAD --oneline" % previous_version
  debug(git_command)
  # These are all the commit messages since the last release.
  gitlog = subprocess.check_output(git_command, shell=True).strip().split("\n")
  # Remove the last log line, because it will just be a commit bumping the
  # version to X.Y.Z.dev0.
  del gitlog[-1]
  return gitlog



def createRelease(remote,
                  release_type,
                  dev_version,
                  previous_version,
                  release_version,
                  confirm=True,
                  dry_run=False):

  gitlog = getGitLog(previous_version)

  if len(gitlog) == 0:
    die("Release contains no changes. Bailing out!")

  print "This release contains %i commit(s)." % len(gitlog)

  # Strip the SHAs off the beginnings of the commit messages.
  gitlog = [" ".join(line.split(" ")[1:]) for line in gitlog]

  updateNupicCoreFiles(dev_version, gitlog, previous_version, release_version)
  commitRelease(release_version)
  tagRelease(release_version)

  if not dry_run:
    pushRelease(release_version, remote)

  return release_version


def getNextReleaseVersion(this_release=None):
  if this_release:
    last_version = this_release
  else:
    with open(VERSION_FILE, "r") as f:
      last_version = f.read().replace('\n', '')
  if last_version[-5:] == DEV_SUFFIX:
    last_version = last_version[0:(0-len(DEV_SUFFIX))]
  dev_split = [int(i) for i in last_version.split('.')]
  dev_split[-1] += 1
  next_version = ".".join([str(i) for i in dev_split])
  return "%s%s" % (next_version, DEV_SUFFIX)


def createDevelopmentVersion(remote, last_version, dev_version, dry_run=False):

  print "\nUpdating version from %s to %s." % (last_version, dev_version)

  print "\nUpdating files..."
  debug("\tUpdating VERSION...")
  replaceInFile(last_version, dev_version, VERSION_FILE)

  debug("\tUpdating Doxyfile...")
  replaceInFile(last_version, dev_version, DOXYFILE)

  print "\nCommitting dev version..."
  git_command = "git commit -am \"Continuing work on %s.\" --no-verify" \
                % dev_version
  debug(git_command)
  subprocess.call(git_command, shell=True)

  if not dry_run:
    print "\nPushing %s..." % remote
    git_command = "git push %s master" % remote
    subprocess.call(git_command, shell=True)



def createGithubRelease(tag, changes):
  print "\nCreating Release %s in GitHub..." % tag
  gh = github.GitHub(GH_TOKEN)
  gh_repo = gh.repo("numenta", "nupic")
  release = gh_repo.releases().create({
    "name": tag,
    "tag_name": tag,
    "body": changes
  })
  return release["html_url"]



# Start here

if __name__ == "__main__":
  (options, args) = parser.parse_args(sys.argv[1:])

  if "NUPIC_CORE" not in os.environ:
    die("Set the NUPIC_CORE environment variable.")
  NUPIC_CORE = os.environ["NUPIC_CORE"]
  if "GH_ACCESS_TOKEN" not in os.environ:
    die("Set the GH_ACCESS_TOKEN environment variable.")
  GH_TOKEN = os.environ["GH_ACCESS_TOKEN"]

  verbose = options.verbose
  remote = options.remote
  release_type = options.release_type
  confirm = not options.auto_confirm
  next_release = options.next_release

  if release_type not in [BUGFIX_RELEASE, MINOR_RELEASE, MAJOR_RELEASE]:
    die("Invalid semantic release type \"%s\"." % release_type)

  # Unpublished feature: first argument can be a path to a repository location.
  # Currently used for testing this script.
  repo = NUPIC_CORE
  if len(args) > 0:
    repo = os.path.abspath(args[0])

  if not userHasPushAccess(remote):
    die("You must have push access to remote \"%s\" to create a release." % remote)

  os.chdir(repo)

  try:

    with open(VERSION_FILE, "r") as f:
      dev_version = f.read().strip()

    previous_version, release_version = findVersions(dev_version, release_type)

    if next_release is None:
      next_release = getNextReleaseVersion(release_version)
    elif next_release[(0 - len(DEV_SUFFIX)):] != DEV_SUFFIX:
      next_release += DEV_SUFFIX


    print "\n ***************************************"
    print   " * Executing %s release." % release_type
    print   " ***************************************\n"
    print "  ➤ Updating version from %s to %s" % (dev_version, release_version)
    print "  ➤ Previous release was %s" % previous_version
    print "  ➤ Next development version will be %s" % next_release

    if confirm:
      proceed = queryYesNo(
        "\n\t** WARNING **: You're about to release NuPIC Core %s (%s).\n"
        "\tThis is a big deal. Are you sure you know what you're doing?"
        % (release_version, release_type)
      )
      if not proceed:
        die(
          "\nRight. Better safe than sorry. "
          "Email hackers@lists.numenta.org to discuss NuPIC releases.\n"
        )

    if repoNeedsUpdate(remote):
      die("Your local repo is not up to date with upstream/master, please sync!")

    release_number = createRelease(remote,
                                    release_type,
                                    dev_version,
                                    previous_version,
                                    release_version,
                                    confirm=confirm,
                                    dry_run=options.dry_run)

    createDevelopmentVersion(remote,
                               release_number,
                               next_release,
                               dry_run=options.dry_run)

    if options.dry_run:
      print "\n%s was committed and tagged locally but not pushed to %s." \
            % (release_number, options.remote)
      print "To reset your local repository to the state it was in before this " \
            "process:"
      print "\tgit reset --hard upstream/master"
      print "\tgit tag -d %s" % release_number
    else:
      try:
        release_url = createGithubRelease(
          release_number, getReleaseNotes(release_number)
        )
        print "See %s" % release_url
      except HTTPError as http_error:
        print http_error
        print("Error publishing release information to GitHub! But don't "
              "worry, you can do that manually at github.com.")
      print "\nDone releasing %s." % release_number

  finally:
    # Always change back to original directory, even if fatal errors occur.
    os.chdir(CWD)
