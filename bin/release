#!/usr/bin/env python
# ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (NuPIC)
# Copyright (C) 2015, Numenta, Inc.  Unless you have an agreement
# with Numenta, Inc., for a separate license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses.
#
# http://numenta.org/licenses/
# ----------------------------------------------------------------------

import sys
import os
import subprocess
from optparse import OptionParser

from libsaas.services import github

# Files that will be modified.
VERSION_FILE = "VERSION"
CHANGELOG_FILE = "CHANGELOG.md"
DOXYFILE = "docs/Doxyfile"
INIT_FILE = "nupic/__init__.py"

# Used for creating the next version after the release. After 1.2.3 comes
# 1.2.3.dev0. Named this way because distutils complains if you use "-dev".
# You know you hate it when distutils complains.
DEV_SUFFIX = ".dev0"

NUPIC = None
GH_TOKEN = None

CWD = os.getcwd()

DEFAULT_RELEASE_TYPE = "bugfix"
DEFAULT_REMOTE = "upstream"
DEFAULT_REPO_DIR = NUPIC

verbose = False
gh = github.GitHub(GH_TOKEN)


# Options parsing.
parser = OptionParser(
  usage="%prog [options]\n\n"
        """
Pushes a new git release using git tags and the GitHub API. Users must have push access to the target repository and a GitHub access token.

This is a work in progress.

## Requirements:
- git
- [GitHub access token](https://github.com/blog/1509-personal-api-tokens)
  - `export GH_ACCESS_TOKEN=<token>`
- Push access to target git repository
- `pip install libsaas`

## Usage

> ./bugfix-release <path-to-repo> [options]

The `path-to-repo` may be a relative or absolute path to the repository being released. If the path is omitted, it's assumed you're releasing NuPIC, so the value of the `NUPIC` environment variable will be used for the repository location.
        """
)
parser.add_option(
  "-v",
  "--verbose",
  action="store_true",
  default=False,
  dest="verbose",
  help="Print debugging statements.")
parser.add_option(
  "-d",
  "--dry_run",
  action="store_true",
  default=False,
  dest="dry_run",
  help="Prevents pushing to remote master branch.")
parser.add_option(
  "-y",
  "--yes",
  action="store_true",
  default=False,
  dest="auto_confirm",
  help="Prevents command line confirmation for the release.")
parser.add_option(
  "-r",
  "--remote",
  default=DEFAULT_REMOTE,
  dest="remote",
  help="Which remote location to push to (default 'upstream').")
parser.add_option(
  "-s",
  "--semantic-release-type",
  default=DEFAULT_RELEASE_TYPE,
  dest="release_type",
  help="Type of semantic release to execute. Must be either \"bugfix\", "
       "\"minor\", or \"major\" (default \"bugfix\").")



def replace_in_file(from_value, to_value, file_path):
  with open(file_path, "r") as f:
    contents = f.read()
  with open(file_path, "wb") as f:
    f.write(contents.replace(from_value, to_value))



def debug(msg):
  if verbose:
    print msg



def die(msg):
  print msg
  os.chdir(CWD)
  exit(-1)



def query_yes_no(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")



def tag_exists(tag):
  git_command = "git tag"
  debug(git_command)
  existing_tags = subprocess.check_output(git_command, shell=True).strip().split("\n")
  return tag in existing_tags



def bail_out(msg):
  debug("Checking out changed files before bailing out...")

  git_command = "git checkout %s %s %s %s" \
                % (CHANGELOG_FILE, VERSION_FILE, DOXYFILE, INIT_FILE)
  debug(git_command)
  subprocess.call(git_command, shell=True)
  die(msg)



def repo_needs_update(remote):
  debug("Checking if local repo needs to be synced with %s..." % remote)

  git_command = "git fetch %s" % remote
  debug(git_command)
  subprocess.call(git_command, shell=True)

  # This gives us a log of all the commits on <remote>/master that aren't on
  # the local checkout's HEAD.
  git_command = "git log HEAD..%s/master --oneline" % remote
  debug(git_command)
  gitlog = subprocess.check_output(git_command, shell=True).strip()

  # If the output is not empty, then the repo needs updating.
  return len(gitlog) > 0



def user_has_push_access(remote):
  debug("Checking if user has push access to %s..." % remote)

  git_command = "git push --dry-run %s master" % remote
  debug(git_command)
  status = subprocess.call(git_command, shell=True)
  # User only has push access if exit status of the push call was 0.
  return status == 0



def find_versions(dev_version, release_type):
  # Turns "X.Y.Z.dev0 into "X.Y.Z".
  expected_next_version = ".".join(dev_version.split(".")[:-1])
  release_split = [int(i) for i in expected_next_version.split('.')]

  release_split[-1] -= 1
  previous_version = ".".join([str(i) for i in release_split])

  if release_type == "bugfix":
    release_version = expected_next_version
  elif release_type == "minor":
    release_split[-2] += 1
    release_split[-1] = 0
    release_version = ".".join([str(i) for i in release_split])
  else:
    release_split[0] += 1
    release_split[1] = 0
    release_split[2] = 0
    release_version = ".".join([str(i) for i in release_split])

  return previous_version, release_version



def create_release(remote, release_type, confirm=True, dry_run=False):
  if repo_needs_update(remote):
    die("Your local repo is not up to date with upstream/master, please sync!")

  with open(VERSION_FILE, "r") as f:
    dev_version = f.read().strip()

  previous_version, release_version = find_versions(dev_version, release_type)

  print "Executing %s release." % release_type
  print "Updating version from %s to %s." % (dev_version, release_version)
  print "Previous release was %s" % previous_version

  if confirm:
    proceed = query_yes_no(
      "\n** WARNING **: You're about to release %s (%s) for the git repo "
      "at %s. This is a big deal. "
      "Are you sure you know what you're doing?"
      % (release_version, release_type, repo)
    )
    if not proceed:
      die(
        "\nRight. Better safe than sorry. "
        "Email hackers@lists.numenta.org to discuss NuPIC releases.\n"
      )


  git_command = "git log %s..HEAD --oneline" % previous_version
  debug(git_command)
  # These are all the commit messages since the last release.
  gitlog = subprocess.check_output(git_command, shell=True).strip().split("\n")

  # Remove the last log line, because it will just be a commit bumping the
  # version to X.Y.Z.dev0.
  del gitlog[-1]

  if len(gitlog) == 0:
    die("Release contains no changes. Bailing out!")

  print "This release contains %i commit(s)." % len(gitlog)

  # Strip the SHAs off the beginnings of the commit messages.
  gitlog = [" ".join(line.split(" ")[1:]) for line in gitlog]

  print "\nUpdating files..."

  debug("\tUpdating VERSION...")
  replace_in_file(dev_version, release_version, VERSION_FILE)

  debug("\tUpdating Doxyfile...")
  replace_in_file(dev_version, release_version, DOXYFILE)

  debug("\tUpdating nupic/__init__.py...")
  replace_in_file(dev_version, release_version, INIT_FILE)

  debug("\tUpdating CHANGELOG.md...")
  # This is a bit more complex than a substitution.
  with open(CHANGELOG_FILE, "r") as f:
    changelog_contents = f.readlines()

  new_changelog_contents = []
  for line in changelog_contents:
    # At the top of the changelog, add a line for this release version.
    if line == "# Changelog\n":
      new_changelog_contents.append(line)
      new_changelog_contents.append("\n## %s\n\n" % release_version)
      changelog_count = 0
      # Loop through all the git log messages since the last version.
      for log_line in gitlog:
        # Ask the user doing the release if they want each commit message in the
        # changelog.
        include = "Include this change in the CHANGELOG?\n\t\"%s\"" % log_line
        if query_yes_no(include):
          changelog_count += 1
          new_changelog_contents.append("* %s\n" % log_line)
    else:
      new_changelog_contents.append(line)

  # If the user doing the release didn't choose any messages to put in the
  # changelog, something is wrong. A release should always have chagnes in the
  # changelog.
  if changelog_count == 0:
    bail_out("You must choose at least one commit message to add to the "
             "CHANGELOG file.")

  with open(CHANGELOG_FILE, "wb") as f:
    f.writelines(new_changelog_contents)

  print "\nCommitting release..."
  git_command = "git commit -am \"Release %s.\" --no-verify" % release_version
  debug(git_command)
  subprocess.call(git_command, shell=True)

  print "\nTagging release..."
  if tag_exists(release_version):
    delete_tag = query_yes_no(
      "Tag %s already exists! Delete it?" % release_version
    )
    if delete_tag:
      git_command = "git tag -d %s" % release_version
      debug(git_command)
      subprocess.call(git_command, shell=True)
    else:
      die("A tag for release %s already exists." % release_version)

  git_command = "git tag -a %s -m \"Release %s\"" \
                % (release_version, release_version)
  debug(git_command)
  subprocess.call(git_command, shell=True)

  if not dry_run:
    print "\nPushing to %s..." % remote
    git_command = "git push %s master" % remote
    debug(git_command)
    subprocess.call(git_command, shell=True)
    
    git_command = "git push %s %s" % (remote, release_version)
    debug(git_command)
    subprocess.call(git_command, shell=True)

  return release_version


def create_development_version(remote, dry_run=False):
  with open(VERSION_FILE, "r") as f:
    last_version = f.read().replace('\n', '')

  dev_split = [int(i) for i in last_version.split('.')]
  dev_split[-1] += 1
  next_version = ".".join([str(i) for i in dev_split])
  dev_version = "%s%s" % (next_version, DEV_SUFFIX)

  print "\nUpdating version from %s to %s." % (last_version, dev_version)

  print "\nUpdating files..."
  debug("\tUpdating VERSION...")
  replace_in_file(last_version, dev_version, VERSION_FILE)

  debug("\tUpdating Doxyfile...")
  replace_in_file(last_version, dev_version, DOXYFILE)

  debug("\tUpdating nupic/__init__.py...")
  replace_in_file(last_version, dev_version, INIT_FILE)

  print "\nCommitting dev version..."
  git_command = "git commit -am \"Continuing work on %s.\" --no-verify" \
                % dev_version
  debug(git_command)
  subprocess.call(git_command, shell=True)

  if not dry_run:
    print "\nPushing %s..." % remote
    git_command = "git push %s master" % remote
    subprocess.call(git_command, shell=True)



if __name__ == "__main__":
  (options, args) = parser.parse_args(sys.argv[1:])

  if "NUPIC" not in os.environ:
    die("Set the NUPIC environment variable.")
  NUPIC = os.environ["NUPIC"]
  if "GH_ACCESS_TOKEN" not in os.environ:
    die("Set the GH_ACCESS_TOKEN environment variable.")
  GH_TOKEN = os.environ["GH_ACCESS_TOKEN"]


  verbose = options.verbose
  remote = options.remote
  release_type = options.release_type
  confirm = not options.auto_confirm

  if release_type not in ["bugfix", "minor", "major"]:
    die("Invalid semantic release type \"%s\"." % release_type)

  repo = DEFAULT_REPO_DIR
  if len(args) > 0:
    repo = os.path.abspath(args[0])

  if not user_has_push_access(remote):
    die("You must have push access to remote \"%s\" to create a release." % remote)

  os.chdir(repo)

  release_number = create_release(remote, release_type, confirm=confirm, dry_run=options.dry_run)
  create_development_version(remote, dry_run=options.dry_run)

  if options.dry_run:
    print "\n%s was committed and tagged locally but not pushed to %s." \
          % (release_number, options.remote)
    print "To reset your local repository to the state it was in before this " \
          "process:"
    print "\tgit reset --hard upstream/master"
    print "\tgit tag -d %s" % release_number
  else:
    print "\nDone releasing %s." % release_number
    print "See https://github.com/numenta/nupic/releases/tag/%s" \
          % release_number

  os.chdir(CWD)
